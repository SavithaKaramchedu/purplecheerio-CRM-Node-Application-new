

const sysserviceconfigfilepath = "../lib/serviceconfig.json";
const deployconfig = require("./deployconfig.json");
const path=require("path");
const fs = require("fs");
const program = require('commander');
const tmpLaunchDir1 = "docker-pc-launch"
const tmpLaunchDir = path.resolve(deployconfig.tmpdir, tmpLaunchDir1);


var strDefDocker = fs.readFileSync(path.resolve(__dirname, "def.docker"), "utf8");


var strPrepCmds = "";
var strCompose = "version: '3'\n";
strCompose += "networks:\n";
strCompose += Tabs(1)+"isolation-network:\n";
strCompose += Tabs(2)+"driver: bridge\n"
strCompose += "services:\n";
strExec = "docker-compose exec";

function Tabs(c)
{
    var strTab = "";
    for(var i=0;i<c;i++)
    {
        strTab += "  ";
    }
    return strTab;
}


function container(sysdeploy)
{
    var sconfig = null;
   
    if(!sysdeploy)
    {
        sconfig = require(path.resolve(deployconfig.appdir, deployconfig.appserviceconfig));
    }
    else
    {
        sconfig = require(sysserviceconfigfilepath);
    }
    for(var s in sconfig.services)
    {
            var strDF = strDefDocker;
        var sc = sconfig.services[s];
        strCompose += Tabs(2)+s+":\n";
        strCompose += Tabs(3)+"build:\n"
        strCompose += Tabs(4)+"context: "+deployconfig.tmpdir+"\n"
        strCompose += Tabs(4)+"dockerfile: "+s+".docker\n"
        strCompose +=  Tabs(3)+"ports:\n";
        strCompose +=  Tabs(4)+"- \""+sc.port+":"+sc.port+"\"\n";
        strCompose += Tabs(3)+"networks:\n";
        strCompose += Tabs(4)+"- isolation-network\n";

        if(deployconfig.npminstall)
        {
            //strCmds += strExec+' '+s+' bash -c "npm install purplecheerio-wave --save"\n';
            strDF += "RUN npm install purplecheerio-wave --save\n";
        }
        else
        {
            strDF += "COPY "+"docker-pc-wave .\n"
        }
        var ddeploy = {
            dnsservicename: true
        }

        var sysfile = path.resolve(tmpLaunchDir,"deploy.json");
        fs.writeFileSync(sysfile, JSON.stringify(ddeploy));

        // COPY deploy.json this enables the service resolution from workflow (see purpleskyutil.js RestTaskCall) to use servicename instead of localhost to find the container url for the service
        var strDF1 = 'COPY '+tmpLaunchDir1+'/deploy.json ./node_modules/purplecheerio-wave/lib\n';

        if(!sysdeploy)
        {
            if(deployconfig.apps[s])
            {
                strDF += strDF1;

                // If apps entry is present for this add the entrypoint using the apps[s] entry in deployconfig.json
                strDF += 'WORKDIR /usr/src/app/'+deployconfig.apps[s].workingdir+'\n';

                strDF += 'ENTRYPOINT '+deployconfig.apps[s].exec+'\n';
                // strDF += 'ENTRYPOINT tail -f /dev/null\n';
            }
            else
            {
                // Generate the app.js
                var strSysApp = 'const app = require("purplecheerio-wave");\n'+
                'app.startservice("'+s+'",".","'+deployconfig.appserviceconfig+'");\n';

                var appfile1 = "app_index_"+s+".js";
                var appfile = path.resolve(tmpLaunchDir, appfile1);
                fs.writeFileSync(appfile, strSysApp);


                // COPY app_index.js and add the entrypoint to the DockerFile
                strDF += 'COPY '+tmpLaunchDir1+"/"+appfile1+' ./app_index.js\n';
                strDF += strDF1;
    
                strDF += 'ENTRYPOINT node app_index.js\n';
                // strDF += 'ENTRYPOINT tail -f /dev/null\n';
            }
        }
        else
        {
            var strSysApp = 'const app = require("purplecheerio-wave");\n'+
            'const initoptions={\n'+
            '"aclconfig":"aclconfig.json",\n'+
            '"secret":"'+deployconfig.secret+'",\n'+
            '"appserviceconfig":"./appserviceconfig.json",\n'+
            '"appdir":"./node_modules/purplecheerio-wave/examples"\n'+
            '};\n'+
            'console.log(JSON.stringify(initoptions, 0, 2));\n'+
            'app.startsystemservice("'+s+'",initoptions);\n';

            var sysfile1 = "sys_index_tmp_"+s+".js";
            var sysfile = path.resolve(tmpLaunchDir,sysfile1);
            fs.writeFileSync(sysfile, strSysApp);
            // COPY sys_index.js and add the entrypoint to the DockerFile
            strDF += 'COPY '+tmpLaunchDir1+"/"+sysfile1+' ./sys_index.js\n';
            strDF += strDF1;


            strDF += 'ENTRYPOINT node sys_index.js\n';
            // strDF += 'ENTRYPOINT tail -f /dev/null\n';
        }
        fs.writeFileSync(path.resolve(__dirname, deployconfig.tmpdir, s+".docker"), strDF);
 
    }
}
function main()
 {
 	//initialize();
 	program
		.version('1.0')
		.option('-f, --filename <fileename>', './tmp/<filename>prep.sh is created to prep & launch containers')
		.option('-c, --cleanup', 'delete contents and the directory deployconfig.tmpdir')
		.parse(process.argv);

	if (!process.argv.slice(2).length) {
	  program.outputHelp();
	  return;
    }
    console.log(program.filename);

	if(program.filename)
	{
        fs.existsSync("tmp") || fs.mkdirSync("tmp");
        if(fs.existsSync(deployconfig.tmpdir))
        {
            if(!program.cleanup)
            {
                console.error("temporary directory designated in deployconfig '"+deployconfig.tmpdir+"' exists and may not be empty. Please empty and delete this directory or change set the deployconfig.tmpdir to another directory");
                var fpath = path.resolve(__dirname, deployconfig.tmpdir);
                if(fpath != deployconfig.tmpdir)
                    console.error("The fully qualified path is "+fpath);
                return;
            }
            var cp = require('child_process');
            if(fs.existsSync(deployconfig.tmpdir+"/docker-pc-launch"))
            {
                cp.execSync("rm -r "+deployconfig.tmpdir+"/docker-pc-launch");
            }
            if(fs.existsSync(deployconfig.tmpdir+"/keymgr.docker"))
            {
                cp.execSync("rm -r "+deployconfig.tmpdir+"/*.docker");
            }
        }
        else
            fs.mkdirSync(deployconfig.tmpdir);

        fs.existsSync(tmpLaunchDir) || fs.mkdirSync(tmpLaunchDir,{recursive:true});
        // The bash script for preparing the docker-pc-wave from current app directory.
        strPrepCmds += "rm -r "+deployconfig.tmpdir+"/docker-pc-wave\n";
        strPrepCmds += "mkdir "+deployconfig.tmpdir+"/docker-pc-wave\n";
        if(deployconfig.npminstall)
        {
            if(deployconfig.appcopy)
                strPrepCmds += 'cp '+path.resolve(deployconfig.appdir)+"/."+' '+deployconfig.tmpdir+'/docker-pc-wave/\n';
            // Copy the launchdir contents also tmp/docker-pc-wave
            strPrepCmds += "cp -r "+tmpLaunchDir+'/ '+deployconfig.tmpdir+'/docker-pc-wave/\n';
        }
        else
        {
            strPrepCmds += "cp -LR ../../node_modules "+deployconfig.tmpdir+"/docker-pc-wave/node_modules\n";
            strPrepCmds += 'cp -LR ../.. '+deployconfig.tmpdir+'/docker-pc-wave/node_modules/purplecheerio-wave\n';
            // Copy the appdir to tmp/docker-pc-wave
            if(deployconfig.appcopy)
                strPrepCmds += 'cp '+path.resolve(deployconfig.appdir)+"/."+' '+deployconfig.tmpdir+'/docker-pc-wave/\n';
            // Copy the launchdir contents also tmp/docker-pc-wave
            strPrepCmds += "cp -r "+tmpLaunchDir+'/ '+deployconfig.tmpdir+'/docker-pc-wave/\n';

            strPrepCmds += "rm -r "+deployconfig.tmpdir+"/docker-pc-wave//node_modules/purplecheerio-wave/node_modules\n";
        }
        strPrepCmds += "docker-compose -f "+program.filename+".yml up --build"

        container(false);
        container(true);
        fs.writeFileSync(path.resolve(__dirname, program.filename+".yml"), strCompose);
        fs.writeFileSync(path.resolve(__dirname, "tmp", program.filename+"prep.sh"), strPrepCmds);
	}
	

 }

 main();